%include macros\gigatron.i

xx              EQU     0x30
yy              EQU     xx + 0x01
ii              EQU     xx + 0x02
jj              EQU     xx + 0x03

index           EQU     xx + 0x04
rotation        EQU     xx + 0x06
indexNext       EQU     xx + 0x08
rotationNext    EQU     xx + 0x0A
tx              EQU     xx + 0x0C
ty              EQU     xx + 0x0E
tw              EQU     xx + 0x10
th              EQU     xx + 0x12
tu              EQU     xx + 0x14
tv              EQU     xx + 0x16
ox              EQU     xx + 0x18
oy              EQU     xx + 0x1A
ov              EQU     xx + 0x1C
oindex          EQU     xx + 0x1E
orotation       EQU     xx + 0x20
tetrominoLut    EQU     xx + 0x22
tetrominoBase   EQU     xx + 0x24
colour          EQU     xx + 0x26
result          EQU     xx + 0x28
frameCounter    EQU     xx + 0x2A
frameCountPrev  EQU     xx + 0x2C
frameTicks      EQU     xx + 0x2E
frameTicksLevel EQU     xx + 0x30
rand            EQU     xx + 0x32
scratch         EQU     xx + 0x34
vbase           EQU     xx + 0x36
xScroll         EQU     xx + 0x38
tbase           EQU     xx + 0x3A
dbase           EQU     xx + 0x3C
textStr         EQU     xx + 0x3E
textPos         EQU     xx + 0x40
textChr         EQU     xx + 0x42
numLines        EQU     xx + 0x44
scoreDelta      EQU     xx + 0x46
scoreLevel      EQU     xx + 0x48
scoreScratch    EQU     xx + 0x4A

kk              EQU     xx + 0x51       ; 0x80 can't be used
ll              EQU     xx + 0x52
mm              EQU     xx + 0x53
nn              EQU     xx + 0x54
tt              EQU     xx + 0x55
buttonStatePrev EQU     xx + 0x56
refresh         EQU     xx + 0x57
blocked         EQU     xx + 0x58
tetrominoNext   EQU     xx + 0x59


    
xTetris         EQU     10
yTetris         EQU     20
xPixels         EQU     xTetris*4
yPixels         EQU     yTetris*4
xOffset         EQU     (giga_xres - xPixels) / 2
yOffset         EQU     (giga_yres - yPixels) / 2
maxLines        EQU     4
maxLevel        EQU     8
maxTicks        EQU     50
deltaTicks      EQU     5
scorePos        EQU     0x6D44
levelPos        EQU     0x6D5F
highPos         EQU     0x1644
multPos         EQU     0x6D3A
fgColourB       EQU     0xFF
bgColourB       EQU     0x15
bgColourW       EQU     0x1515
             
_startAddress_      EQU     0x0200      ; entry point for the code, if this is missing defaults to 0x0200

_callTable_         EQU     0x00EE      ; call addresses are automatically stored here by the assembler, it grows downwards, (leave 16 bytes for vCPU stack)
                                        ; *NOTE* gt1 spec only allows for one zero page segment, .vasm files use this for the call table
                                        ; do not define any data/constants in zero page using DB or DW, it will not work! (use code)
                                        
_singleStepWatch_   EQU     frameCounter ; the single step debugger watches this variable location to decide when to step,
                                         ; choose a variable that is updated often

; tetromino data
tetromino_I     EQU     0x08A1          ; format: colour for 2 pixels, w, h, ox, oy, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0  ; ox and oy are offsets within w and h
tetromino_J     EQU     tetromino_I + 0x0100
tetromino_L     EQU     tetromino_I + 0x0200
tetromino_O     EQU     tetromino_I + 0x0300
tetromino_S     EQU     tetromino_I + 0x0400
tetromino_T     EQU     tetromino_I + 0x0500
tetromino_Z     EQU     tetromino_I + 0x0600                                                                                  
tetromino_I     DB      0x3C 0x3C 4 1 0 1 0 1 1 1 2 1 3 1 0 0  0x3C 0x3C 1 4 2 0 2 0 2 1 2 2 2 3 0 0  0x3C 0x3C 4 1 0 2 0 2 1 2 2 2 3 2 0 0  0x3C 0x3C 1 4 1 0 1 0 1 1 1 2 1 3 0 0
tetromino_J     DB      0x30 0x30 3 2 0 0 0 0 0 1 1 1 2 1 0 0  0x30 0x30 2 3 1 0 1 0 2 0 1 1 1 2 0 0  0x30 0x30 3 2 0 1 0 1 1 1 2 1 2 2 0 0  0x30 0x30 2 3 0 0 1 0 1 1 0 2 1 2 0 0  
tetromino_L     DB      0x0B 0x0B 3 2 0 0 2 0 0 1 1 1 2 1 0 0  0x0B 0x0B 2 3 1 0 1 0 1 1 1 2 2 2 0 0  0x0B 0x0B 3 2 0 1 0 1 1 1 2 1 0 2 0 0  0x0B 0x0B 2 3 0 0 0 0 1 0 1 1 1 2 0 0
tetromino_O     DB      0x0F 0x0F 2 2 0 0 0 0 1 0 0 1 1 1 0 0  0x0F 0x0F 2 2 0 0 0 0 1 0 0 1 1 1 0 0  0x0F 0x0F 2 2 0 0 0 0 1 0 0 1 1 1 0 0  0x0F 0x0F 2 2 0 0 0 0 1 0 0 1 1 1 0 0
tetromino_S     DB      0x0C 0x0C 3 2 0 0 1 0 2 0 0 1 1 1 0 0  0x0C 0x0C 2 3 1 0 1 0 1 1 2 1 2 2 0 0  0x0C 0x0C 3 2 0 1 1 1 2 1 0 2 1 2 0 0  0x0C 0x0C 2 3 0 0 0 0 0 1 1 1 1 2 0 0
tetromino_T     DB      0x33 0x33 3 2 0 0 1 0 0 1 1 1 2 1 0 0  0x33 0x33 2 3 1 0 1 0 1 1 2 1 1 2 0 0  0x33 0x33 3 2 0 1 0 1 1 1 2 1 1 2 0 0  0x33 0x33 2 3 0 0 1 0 0 1 1 1 1 2 0 0
tetromino_Z     DB      0x03 0x03 3 2 0 0 0 0 1 0 1 1 2 1 0 0  0x03 0x03 2 3 1 0 2 0 1 1 2 1 1 2 0 0  0x03 0x03 3 2 0 1 0 1 1 1 1 2 2 2 0 0  0x03 0x03 2 3 0 0 1 0 0 1 1 1 0 2 0 0

scoringLut      EQU     tetromino_I + 0x0700
levellingLut    EQU     tetromino_I + 0x0705
scoringLut      DB      10 25 50 100
levellingLut    DW      250 750 1000 2000 4000 8000 16000 32000 64000

digit_font0     EQU     0x7AA1
digit_font1     EQU     0x7BA1
digit_font2     EQU     0x7CA1
digit_font3     EQU     0x7DA1
digit_font4     EQU     0x7EA1
digit_font0     DB      fgColourB fgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB bgColourB bgColourB bgColourB
digit_font1     DB      fgColourB bgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB
digit_font2     DB      fgColourB bgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB fgColourB fgColourB fgColourB bgColourB bgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB
digit_font3     DB      fgColourB bgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB bgColourB bgColourB bgColourB bgColourB fgColourB bgColourB bgColourB
digit_font4     DB      fgColourB fgColourB fgColourB bgColourB bgColourB fgColourB bgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB bgColourB bgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB fgColourB fgColourB bgColourB fgColourB bgColourB fgColourB bgColourB

score_string    EQU     0x7FA1
high_string     EQU     0x7FA8
level_string    EQU     0x7FAF
mult_string     EQU     0x7FB2
score_string    DB      6 '000000'
high_string     DB      6 '000000'
;level_string    DB      7 'LEVEL 0'
; TODO: build a complete font set, right now ':' = 'L' and ';' = 'x'
level_string    DB      2 ':0'
mult_string     DB      2 ';1'


; tetromino_I gets an extra slot to make rand easier to implement, this also means tetromino_I will appear statistically more often,
; replace with which ever tetromino you want to favour
tetromino_lut   EQU     0x08E0
tetromino_lut   DW      tetromino_I tetromino_J tetromino_L tetromino_O tetromino_S tetromino_T tetromino_Z tetromino_I


entry_point     EQU     0x0200
handleInput     EQU     entry_point + 0x0100
updateScore     EQU     entry_point + 0x0200        ; too big to store in unused area of video memory
incrementScore  EQU     entry_point + 0x0300        ; too big to store in unused area of video memory


; storing subroutines in unused areas of video memory
clearBoard      EQU     0x15A1      
clearScreen     EQU     clearBoard + 0x0100
setTetrisBlock  EQU     clearBoard + 0x0200
drawTetromino   EQU     clearBoard + 0x0300
drawNextTet     EQU     clearBoard + 0x0400
drawTetrisField EQU     clearBoard + 0x0500
drawTFtopH      EQU     clearBoard + 0x0600
drawTFbotH      EQU     clearBoard + 0x0700
eraseTetromino  EQU     clearBoard + 0x0800
eraseTrCorner   EQU     clearBoard + 0x0900
getTetrisBlock  EQU     clearBoard + 0x0A00
checkTetromino  EQU     clearBoard + 0x0B00
spawnTetromino  EQU     clearBoard + 0x0C00
updateTetromino EQU     clearBoard + 0x0D00
checkLines      EQU     clearBoard + 0x0E00
moveLines       EQU     clearBoard + 0x0F00
shakeScreen     EQU     clearBoard + 0x1000
printText       EQU     clearBoard + 0x1100
printDigits     EQU     clearBoard + 0x1200
resetLevel      EQU     clearBoard + 0x1300
resetScore      EQU     clearBoard + 0x1400
incrementLevel  EQU     clearBoard + 0x1500
loadTetromino   EQU     clearBoard + 0x1600


%include tetris\macros.i
%include tetris\clear_board.i
%include tetris\draw_tetromino.i
%include tetris\erase_tetromino.i
%include tetris\check_tetromino.i
%include tetris\spawn_tetromino.i
%include tetris\check_lines.i
%include tetris\print_text.i
%include tetris\update_score.i


entry_point     LDWI    giga_vram
                STW     vbase               ; vram base address
                LDWI    giga_text32
                STW     tbase               ; text font base address, (ROM)
                LDWI    digit_font0         
                STW     dbase               ; tiny digit font base address, (RAM)
                LDWI    0x0101
                STW     xScroll
                
                CALL    clearScreen
                CALL    drawTetrisField

                ; shift right by 4 test
                ;LDWI    SYS_LSRW4_50        ; setup >>4 SYS routine
                ;STW     giga_sysFn
                ;LDWI    0xFF00
                ;SYS     0xF5            ; SYS_Draw4_50, 270 - 50/2 = 0xF5
                ;STW     scratch
                ;gprintf("Scratch = %04x", *scratch)

restart         CALL    resetLevel
                CALL    resetScore
                CALL    clearBoard 

                LDWI    0x0000
                STW     scoreDelta
                STW     scoreLevel
                STW     frameCounter    

                LDWI    maxTicks
                STW     frameTicksLevel
                STW     frameTicks

                LD      giga_rand0
                ST      tetrominoNext

                LDI     0x00
                ST      blocked
                
                LD      giga_frameCount
                STW     frameCountPrev

                LDWI    tetromino_lut
                STW     tetrominoLut
                     
                CALL    spawnTetromino
                
                ; main update loop
update          ST      scratch
                CALL    saveTetromino

                ;gprintf("%c %d $%04x $%04x $%04x b%016b b%08b o%04o $%04x %s", 48, 45000, 0xDEAD, 0xBEEF, resetLevel, frameCountPrev, *frameCounter, maxTicks + 1, vBlank, *level_string)

                ; wait for VBlank
vBlank          LD      giga_frameCount
                SUBW    frameCountPrev
                BEQ     vBlank
                LD      giga_frameCount
                STW     frameCountPrev
                
                ; input
                CALL    handleInput
                ST      refresh
                XORI    0xFB            ; down
                BEQ     frame_count1
                LD      refresh         ; all other input
                BNE     erase

                ; reset frameTicks
                LDW     frameTicksLevel
                STW     frameTicks

                ; frameTicks defines speed of tetrominoes
frame_count1    LDW     frameCounter
                ADDI    0x01
                STW     frameCounter
                SUBW    frameTicks
                BLT     vBlank

                ; don't allow input to override timing
                LDI     0x00
                ST      refresh

                ; erase old tetromino
erase           LD      blocked
                BNE     check_txl
                CALL    eraseTetromino

                ; if(tx < 0 - tu) tx = 0 - tu;
check_txl       LDW     tx              
                ADDW    tu
                BGE     check_txr
                LDWI    0x00
                SUBW    tu
                STW     tx
                BRA     frame_count0

                ; if(tx > TETRIS_XEXT - tw - tu) tx = TETRIS_XEXT - tw - tu;
check_txr       LDW     tx              
                ADDW    tw
                ADDW    tu
                SUBI    xTetris
                BLE     frame_count0
                LDWI    xTetris
                SUBW    tw
                SUBW    tu
                STW     tx

                ; if(frameCount >= frameTick)
frame_count0    LDW     frameCounter    
                SUBW    frameTicks
                BLT     check_blocks
                LDWI    0x0000
                STW     frameCounter   
                LDI     0x00            ; reset flicker control                
                ST      blocked

                ; gravity    
                INC     ty                  

                ; if(y > TETRIS_YEXT - h)
                LDW     ty
                ADDW    th
                SUBI    yTetris
                BLE     check_blocks

                ; draw floor tetromino
                LD      ty
                SUBI    0x01
                ST      ty
                CALL    drawTetromino 

                ; spawn new tetromino
                CALL    spawnTetromino
                LDI     0xFF            ; control flicker
                ST      blocked
                BRA     update

                ; check new tetromino position
check_blocks    CALL    checkTetromino      ; checks tetromino for occupied blocks, returns result, 0 = empty, 1 = game over, >1 = blocked
                LDW     result
                BEQ     draw_new

                ; check for game over
                SUBI    0x01
                BEQ     restart
 
                ; check for fall blocked whilst input active, (but not drop)
                LD      refresh
                BEQ     fall_blocked

                ; load old tetromino
                CALL    loadTetromino
                BRA     draw_new

                ; draw falling blocked tetromino at previous y position
fall_blocked    LD      ty
                SUBI    0x01
                ST      ty
                CALL    drawTetromino 

                ; spawn new tetromino
                CALL    spawnTetromino
                BRA     update

draw_new        CALL    drawTetromino 
                BRA     update

                
                ; load tetromino state
loadTetromino   LDW     ox          
                STW     tx
                LDW     oy          
                STW     ty
                LDW     ov              ; vertical offset in tetris block units
                STW     tv
                LDW     oindex
                STW     index
                LDW     orotation
                STW     rotation
                RET

                ; save tetromino state
saveTetromino   LDW     tx          
                STW     ox
                LDW     ty          
                STW     oy
                LDW     tv              ; vertical offset in tetris block units
                STW     ov
                LDW     index
                STW     oindex
                LDW     rotation
                STW     orotation
                RET


                ; handle input, returns 0x00 if nothing was handled, otherwise returns input
handleInput     LD      giga_buttonState     ; 0xFF is no input
                XORI    0xFF
                BNE     handleI_down
                ST      buttonStatePrev ; return 0x00     
                RET

                ; level triggered buttons
handleI_down    LD      giga_buttonState
                XORI    0xFB            ; down
                BNE     handleI_event
                LDWI    2
                STW     frameTicks
                LD      giga_buttonState
                RET

                ; edge triggering
handleI_event   LD      buttonStatePrev ; only handle new events
                BEQ     handleI_left
                LD      0x00
                RET

                ; edge triggered buttons
handleI_left    LD      giga_buttonState
                ST      buttonStatePrev
                XORI    0xFD            ; left
                BNE     handleI_right

                LDW     tx              ; tx--
                SUBI    0x01
                STW     tx
                LD      giga_buttonState
                RET

handleI_right   LD      giga_buttonState
                XORI    0xFE            ; right
                BNE     handleI_up

                LDW     tx              ; tx++
                ADDI    0x01
                STW     tx
                LD      giga_buttonState
                RET

handleI_up      LD      giga_buttonState
                XORI    0xF7            ; up
                BNE     handleI_exit

                LDW     rotation
                STW     scratch
                ADDI    0x10            ; rotation table's are separated by 16 bytes
                ANDI    0x30            ; 4 rotation patterns
                STW     rotation
                PUSH
                CALL    updateTetromino
                POP

                ; check rotation
                LDW     ty              ; if(ty > TETRIS_YEXT - th - tv)
                ADDW    th
                ADDW    tv
                SUBI    yTetris
                BLE     handleI_exit

                ; restore rotation
                LDW     scratch
                STW     rotation
                PUSH
                CALL    updateTetromino
                POP
                LD      0x00
                RET

handleI_exit    LD      giga_buttonState
                RET
